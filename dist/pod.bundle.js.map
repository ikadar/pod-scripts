{"version":3,"file":"pod.bundle.js","sources":["../src/separator.js","../src/render-template.js","../src/smart-caps.js","../src/conversion.js","../src/measurement.js","../src/squeeze/squeeze-font-size.js","../src/squeeze/squeeze-letter-spacing.js","../src/squeeze/squeeze-scaling.js","../src/squeeze.js","../src/post-msg-handler.js","../src/pod-template-scripts.js"],"sourcesContent":["import logInfo from \"./log-info\";\n\nconst handleSeparators = () => {\n\n    // logInfo(\"HANDLING SEPARATORS\");\n\n    const results = Array.from(document.querySelectorAll('[class*=\"separator-[\"]'))\n        .map(el => {\n            const m = el.className.match(/separator-\\[([^\\]]+)\\]/);\n            return m ? { element: el, value: m[1] } : null;\n        })\n        .filter(Boolean);\n\n    results.forEach(({ element, value }) => {\n        const textNodes = getAllTextNodes(element);\n        textNodes.forEach(node => wrapMatchesWithSeparatorAndSegments(node, value));\n    });\n\n    const separatorNodeList = document.querySelectorAll(\".separator\");\n    const separators = Array.from(separatorNodeList);\n\n    separators.map((separator) => {\n        const next = separator.nextElementSibling;\n        const prev = separator.previousElementSibling;\n\n        let nextInNewLine = false;\n        let prevInNewLine = false;\n\n        if (next) {\n            if (getYCoordinate(separator) !== getYCoordinate(next)) {\n                nextInNewLine = true;\n            }\n        }\n\n        if (prev) {\n            if (getYCoordinate(separator) !== getYCoordinate(prev)) {\n                prevInNewLine = true;\n            }\n        }\n\n        if (nextInNewLine) {\n            separator.style.visibility = \"hidden\";\n        } else {\n            separator.style.visibility = \"visible\";\n        }\n\n        if (prevInNewLine) {\n            separator.style.display = \"none\";\n        } else {\n            separator.style.display = \"inline\";\n        }\n\n    });\n};\n\nfunction getAllTextNodes(root) {\n    const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null, false);\n    const nodes = [];\n    let n;\n    while ((n = walker.nextNode())) {\n        if (!(n.parentNode.tagName === \"SPAN\" && n.parentNode.classList.item(0) === \"separator\")) {\n            nodes.push(n);\n        }\n    }\n    return nodes;\n}\n\nfunction wrapMatchesWithSeparatorAndSegments(textNode, value) {\n    if (!value) return;\n    const text = textNode.nodeValue;\n    const valLen = value.length;\n    if (!valLen) return;\n\n    let idx = text.indexOf(value);\n    if (idx === -1) return; // nincs találat ebben a node-ban\n\n    const frag = document.createDocumentFragment();\n    let start = 0;\n\n    while (idx !== -1) {\n        const before = text.slice(start, idx);\n\n        // 1) value ELŐTTI rész: ha van nem-whitespace tartalom, csomagoljuk <span>-be\n        const beforeTrim = before.trim();\n        if (beforeTrim.length > 0) {\n            const spanBefore = document.createElement('span');\n            spanBefore.textContent = beforeTrim;\n            frag.appendChild(spanBefore);\n        } else {\n            // ha csak whitespace volt, azt hagyjuk figyelmen kívül – a separator elé úgyis beszúrunk 1 szóközt\n        }\n\n        // 2) kötelező space a separator ELÉ\n        frag.appendChild(document.createTextNode(' '));\n\n        // 3) a separator maga\n        const sep = document.createElement('span');\n        sep.className = 'separator';\n        sep.textContent = value;\n        frag.appendChild(sep);\n\n        // 4) kötelező space a separator MÖGÉ\n        frag.appendChild(document.createTextNode(' '));\n\n        // következő keresési ablak\n        start = idx + valLen;\n        idx = text.indexOf(value, start);\n    }\n\n    // 5) értékeljük a LEGUTOLSÓ találat UTÁNI részt\n    const after = text.slice(start);\n    const afterTrim = after.trim();\n\n    if (afterTrim.length > 0) {\n        // ha van tartalom, az tartalom legyen spanban, a whitespace-ek maradjanak külön text node-ként\n        const leadingWs = after.match(/^\\s*/)?.[0] ?? '';\n        const trailingWs = after.match(/\\s*$/)?.[0] ?? '';\n        if (leadingWs) frag.appendChild(document.createTextNode(leadingWs));\n\n        const spanAfter = document.createElement('span');\n        spanAfter.textContent = afterTrim;\n        frag.appendChild(spanAfter);\n\n        if (trailingWs) frag.appendChild(document.createTextNode(trailingWs));\n    } else {\n        // csak whitespace maradt → tegyük vissza változatlanul\n        if (after) frag.appendChild(document.createTextNode(after));\n    }\n\n    // 6) cseréljük a text node-ot az új tartalomra\n    textNode.parentNode?.replaceChild(frag, textNode);\n}\n\nconst getYCoordinate = (element) => {\n    return element.getBoundingClientRect().top;\n};\n\nexport default handleSeparators;\n","let templateScripts = () => {}\n\nconst setTemplateScripts = (scripts) => {\n    templateScripts = scripts;\n}\n\nfunction scriptFromTheTemplate() {\n    // logInfo(\"scriptFromTheTemplate\");\n    // replace by the scriptFromTheTemplate\n}\n\nfunction renderTemplate(data, templateId, orderLineUuid, options, sendData) {\n\n    const sourceNode = document.getElementById('entry-template');\n\n    if (!sourceNode) {\n        return false;\n    }\n\n    if (Object.keys(data).length === 0) {\n        return false;\n    }\n\n    const source = sourceNode.innerHTML;\n\n    // Wrap each string property in SafeString\n    const safeData = JSON.parse(JSON.stringify(data), (key, value) =>\n        typeof value === 'string' ? value.replace(/\\\\n/g, \"<br />\") : value\n    );\n\n    var renderer = Twig.twig({\n        data: source\n    });\n\n    const html = renderer.render(safeData);\n\n    document.getElementsByTagName('body')[0].outerHTML = html;\n\n    scriptFromTheTemplate();\n    templateScripts();\n\n    if (sendData) {\n        window.parent.postMessage({source: \"template-processor\", html: html, data: data, templateId: templateId, orderLineUuid: orderLineUuid, options: options}, \"*\");\n    }\n\n    return true;\n}\n\nfunction zoom(ratio) {\n    const scale = ratio + \" \" + ratio;\n    document.getElementsByTagName('body')[0].style.scale = ratio;\n}\n\nexport {renderTemplate, setTemplateScripts, zoom};\n","\nfunction smartCaps() {\n\n    const ignore = [\n        \"rue\", \"avenue\", \"impasse\", \"allée\", \"boulevard\", \"place\", \"route\", \"voie\", \"de\", \"la\", \"le\", \"les\", \"lès\", \"au\", \"aux\", \"du\", \"quai\", \"promenade\", \"chemin\", \"sentier\", \"passage\", \"square\", \"cours\", \"traverse\", \"piétonne\", \"résidence\", \"esplanade\", \"rond-point\", \"carrefour\", \"giratoire\", \"faubourg\", \"cour\", \"courtil\", \"clos\", \"cité\", \"villa\", \"hameau\", \"lieu-dit\", \"lotissement\", \"enclos\", \"chaussée\", \"parvis\", \"digue\", \"port\", \"berges\", \"traboule\", \"estrade\", \"estay\", \"rampe\", \"immeuble\", \"batiment\", \"bâtiment\"\n    ];\n\n    function getTextNodesInSmartCap(root = document) {\n        const result = [];\n        const elements = root.querySelectorAll('.smartCap');\n\n        elements.forEach(el => {\n            const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT);\n            let node;\n            while ((node = walker.nextNode())) {\n                const text = node.nodeValue;\n                if (text.trim().length > 0) {\n                    node.nodeValue = text.replace(/\\w\\S*/g, function (word) {\n                        const lower = word.toLowerCase();\n                        if (ignore.includes(lower)) {\n                            return word;\n                        }\n\n                        if (lower.startsWith(\"d'\") || lower.startsWith(\"l'\")) {\n                            const prefix = lower.slice(0, 2); // \"d'\" or \"l'\"\n                            const rest = lower.slice(2);\n                            return prefix + rest.charAt(0).toUpperCase() + rest.slice(1);\n                        }\n\n                        return word.charAt(0).toUpperCase() + word.slice(1);\n                    });\n                    result.push(node);\n                }\n            }\n        });\n\n        return result;\n    }\n\n    const smartCapsNodeList = getTextNodesInSmartCap();\n    const smartCaps = Array.from(smartCapsNodeList);\n\n    smartCaps.forEach(smartCap => {\n        // logInfo(smartCap);\n    })\n}\n\nexport default smartCaps;","function convertToPt(size) {\n\n    var dpi = 74.999943307122;\n\n    const pointsPerInch = 72; // 1 inch = 72 points\n    // const pointsPerInch = dpi; // 1 inch = 72 points\n    const conversionFactors = {\n        pt: 1,                         // 1 pt = 1 pt\n//        px: pointsPerInch / dpi,       // px to pt depends on DPI\n        px: dpi / 100,       // px to pt depends on DPI\n        mm: 3.7795275591 * dpi / 100,  // 1 mm = 1 inch / 25.4\n        // mm: pointsPerInch / 25.4,   // 1 mm = 1 inch / 25.4\n        cm: pointsPerInch / 2.54,      // 1 cm = 1 inch / 2.54\n        in: 96 * dpi / 100,            // 1 inch = 72 pt\n        // in: pointsPerInch,          // 1 inch = 72 pt\n        pc: 16 * dpi,                  // 1 pica (pc) = 12 pt\n        em: 16 * dpi,                  // Assuming 1 em ≈ 12 pt (adjust if needed)\n        rem: 16 * dpi                  // Assuming 1 rem ≈ 12 pt (adjust if needed)\n    };\n\n    // Extract the numeric value and the unit from the size string\n    // const match = size.match(/^([\\d.]+)([a-z%]*)$/i);\n    // const match = size.match(/^-?([\\d.]+)([a-z%]*)$/i);\n    const match = size.match(/^(-?[\\d.]+)([a-z%]*)$/i);\n\n    if (!match) {\n        throw new Error(\"Invalid size format: \" + size);\n    }\n\n    const value = parseFloat(match[1]);\n    let unit = match[2].toLowerCase();\n\n    // If no unit is provided, assume 'px' by default\n    if (!unit) {\n        unit = \"px\";\n    }\n\n    if (!conversionFactors[unit]) {\n        throw new Error(\"Unsupported unit: \" + unit);\n    }\n\n    // logInfo(\"IN: \" + size);\n    // logInfo(\"OUT: \" + value * conversionFactors[unit]);\n\n    return value * conversionFactors[unit];\n\n}\n\nexport default convertToPt;","import convertToPt from \"./conversion\";\n\n/**\n * Megméri egy elem „természetes” szélességét: max-width nélkül, egy sorban.\n * A mérés előtt megvárja a webfontok betöltését.\n * Visszatérési érték: px (number). Ha pt kell, szorozd 0.75-tel (96dpi).\n */\nfunction getElementBoxWidth(el, overflown=true) {\n    if (!(el instanceof Element)) throw new Error('measureInlineWidthNowrap: el must be Element');\n\n    // 2) eredeti inline stílusok mentése\n    const prev = {\n        maxWidth: el.style.maxWidth,\n        whiteSpace: el.style.whiteSpace,\n        transform: el.style.transform,\n        display: el.style.display,\n    };\n\n    try {\n        // 3) mérési állapot\n        el.style.maxWidth   = 'none';\n        el.style.whiteSpace = 'nowrap';\n        // el.style.transform  = 'none'; // scale/rotate ne torzítson\n        el.style.display = 'inline-block';\n        // el.style.display = 'inline-block';\n\n        // 4) reflow trigger (biztos ami biztos)\n        // eslint-disable-next-line no-unused-expressions\n        el.offsetWidth;\n\n        // // 5) mérés\n        // const wPx = window.getComputedStyle(el).width;\n        // console.log(`${el.id}: ${wPx}`);\n        // return convertToPt(`${wPx}`);\n        // 5) mérés\n        const wPx = el.getBoundingClientRect().width;\n        let wPx2 = 0;\n        if (overflown) {\n            el.style.display = 'inline';\n            wPx2 = el.getBoundingClientRect().width;\n        }\n        // console.log(`${el.id}: ${wPx}`);\n        return convertToPt(`${Math.max(wPx, wPx2)}px`);\n    } finally {\n        // 6) visszaállítás\n        el.style.maxWidth   = prev.maxWidth;\n        el.style.whiteSpace = prev.whiteSpace;\n        // el.style.transform  = prev.transform;\n        el.style.display = prev.display;\n    }\n}\n\nfunction getTextNodeLineCount(textNode) {\n    if (!textNode || textNode.nodeType !== Node.TEXT_NODE) return 0;\n\n    const range = document.createRange();\n    range.selectNodeContents(textNode);\n\n    // Ez egy NodeList-szerű objektum, minden rect egy sor vagy fragment\n    const rects = range.getClientRects();\n\n    return rects.length;\n}\n\nfunction getAllTextNodes(root) {\n    const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null, false);\n    const out = [];\n    let n;\n    while ((n = walker.nextNode())) {\n        // üres/whitespace-only node-ok nem érdekelnek\n        if (n.nodeValue && n.nodeValue.trim().length) out.push(n);\n    }\n    return out;\n}\n\n/**\n * Sorok számát adja vissza bármilyen DOM node leszármazott textjeire.\n * A rect-eket top szerint csoportosítja (epsilon toleranciával),\n * így elkerüli a túl-számolást inline fragmentek miatt.\n */\nfunction getRenderedLineCountForNode(node, { epsilon = 0.5 } = {}) {\n    if (!node) return 0;\n\n    const rects = [];\n\n    // 1) gyűjtsük ki minden text node sor-fragment rectjeit\n    for (const tn of getAllTextNodes(node)) {\n        const range = document.createRange();\n        range.selectNodeContents(tn);\n        const rlist = range.getClientRects();\n        for (let i = 0; i < rlist.length; i++) {\n            const r = rlist[i];\n            // 0 szélességű/magasságú vagy display:none esetek kiszűrése\n            if (r.width > 0 && r.height > 0) {\n                rects.push({ top: r.top, bottom: r.bottom, left: r.left, right: r.right, height: r.height });\n            }\n        }\n    }\n\n    if (rects.length === 0) return 0;\n\n    // 2) top szerint rendezzük\n    rects.sort((a, b) => a.top - b.top);\n\n    // 3) klaszterezés top alapján (epsilon px tűrés)\n    let lines = 0;\n    let currentTop = rects[0].top;\n\n    for (const r of rects) {\n        if (Math.abs(r.top - currentTop) > epsilon) {\n            lines++;\n            currentTop = r.top;\n        }\n    }\n    // az első klaszter is számít:\n    return lines + 1;\n}\n\nfunction getScaleX(el) {\n    const style = window.getComputedStyle(el);\n    const transform = style.transform;\n\n    if (!transform || transform === \"none\") {\n        return 1; // nincs transzformáció → scaleX = 1\n    }\n\n    if (transform.startsWith(\"matrix3d\")) {\n        // matrix3d(a1, a2, ..., a16)\n        const values = transform.slice(9, -1).split(\",\").map(parseFloat);\n        return values[0]; // a1 = scaleX\n    }\n\n    if (transform.startsWith(\"matrix\")) {\n        // matrix(a, b, c, d, e, f)\n        const values = transform.slice(7, -1).split(\",\").map(parseFloat);\n        return values[0]; // a = scaleX\n    }\n\n    return 1; // fallback\n}\n\nexport {getElementBoxWidth, getTextNodeLineCount, getRenderedLineCountForNode, getScaleX};","import convertToPt from \"../conversion\";\nimport {getElementBoxWidth, getRenderedLineCountForNode, getTextNodeLineCount} from \"../measurement\";\n\nconst elementsToSqueeze = [];\n\nfunction calculateSqueezedFontSize (maxFontSizePt, maxWidthPt, actualWidthPt, actualFontSizePt) {\n\n    const scale = maxWidthPt / actualWidthPt;\n    const newFontSizePt = parseFloat(actualFontSizePt) * scale;\n    // return newFontSizePt;\n    return Math.min(newFontSizePt, maxFontSizePt);\n}\n\nfunction squeeze (s) {\n    // console.log(s);\n\n    const rowCount = getRenderedLineCountForNode(s.element);\n    // const rowCount = getTextNodeLineCount(s.element.childNodes[0]);\n    if (rowCount <= s.maxRows && s.maxRows > 1) {\n        return;\n    }\n\n    if (s.maxRows > 1) {\n        // fitTextToMaxRows(s.element.childNodes[0], s.maxRows, {\n        fitTextToMaxRows(s.element, s.maxRows, {\n            minFontSize: s.minFontSizePt\n        });\n        return;\n    }\n\n    const actualFontSize = convertToPt(window.getComputedStyle(s.element).fontSize);\n    const actualWidthPt = getElementBoxWidth(s.element);\n\n    var newFontSizePt = calculateSqueezedFontSize(s.maxFontSizePt, s.maxWidthPt, actualWidthPt, actualFontSize);\n    console.log(`${s.element.id}: ${actualFontSize} - ${newFontSizePt} | ${actualWidthPt} - ${s.maxWidthPt}`);\n    // var newFontSizePt = calculateSqueezedFontSize(s.maxFontSizePt, s.maxWidthPt, getElementBoxWidth(s.element), s.element.style.fontSize);\n    newFontSizePt = Math.max(newFontSizePt, s.minFontSizePt);\n    // newFontSizePt = Math.floor(newFontSizePt * 10) / 10;\n    s.element.style.fontSize = newFontSizePt.toString() + \"pt\";\n\n    while (getRenderedLineCountForNode(s.element) > 1) {\n        newFontSizePt -= 0.1;\n        s.element.style.fontSize = newFontSizePt.toString() + \"pt\";\n    }\n\n    s.element.style.maxWidth = s.maxWidth + \"pt\";\n}\n\n// get elements with squeeze and squeeze-[*] classes\nfunction getElementsToSqueeze () {\n    const squeezeElements = document.querySelectorAll('.squeeze');\n    const squeezeElementsWithParams = [];\n\n    // convert nodeList to array\n    for (var i=0; i<squeezeElements.length; i++) {\n        squeezeElementsWithParams.push(squeezeElements[i]);\n    }\n\n    return squeezeElementsWithParams;\n}\n\nfunction squeezeAll () {\n    // prepareElements();\n    for (var i in elementsToSqueeze) {\n        squeeze(elementsToSqueeze[i]);\n    }\n}\n\nfunction prepareElements () {\n    const elements = getElementsToSqueeze();\n    elements.map(function (element, index) {\n\n        let maxWidth = window.getComputedStyle(element).maxWidth;\n        if (!maxWidth || maxWidth === \"none\") {\n            element.style.maxWidth = \"inherit\";\n            maxWidth = window.getComputedStyle(element).maxWidth;\n        }\n        let maxFontSize = window.getComputedStyle(element).fontSize;\n        const currentWidth = window.getComputedStyle(element).width;\n\n        if (!maxWidth || !maxFontSize || maxWidth === \"none\" || maxFontSize === \"none\") {\n            return;\n        }\n\n        element.style.width = maxWidth;\n        const maxWidthPt = getElementBoxWidth(element, false);\n        element.style.width = currentWidth;\n\n        const classArray = Array.from(element.classList);\n        const maxMatch = classArray.find(c => c.startsWith('max-font-size-'))?.match(/^max-font-size-\\[([^\\]]+)\\]$/);\n        const maxFontSizePt = maxMatch ? convertToPt(maxMatch[1]) : convertToPt(maxFontSize);\n        const minMatch = classArray.find(c => c.startsWith('min-font-size-'))?.match(/^min-font-size-\\[([^\\]]+)\\]$/);\n        const minFontSizePt = minMatch ? convertToPt(minMatch[1]) : null;\n\n        const maxRowsMatch = classArray.find(c => c.startsWith('max-rows-'))?.match(/^max-rows-\\[([^\\]]+)\\]$/);\n        const maxRows = maxRowsMatch ? maxRowsMatch[1] : 1;\n\n        // const maxWidthPt = convertToPt(maxWidth);\n        // const maxFontSizePt = convertToPt(maxFontSize);\n\n        elementsToSqueeze[index] = {\n            element: elements[index],\n            maxWidthPt: maxWidthPt,\n            maxFontSizePt: maxFontSizePt,\n            minFontSizePt: minFontSizePt,\n            maxRows: maxRows,\n        };\n\n        // element.style.fontSize = \"1pt\";\n        element.style.display = \"inline\";\n        // element.style.display = \"inline-block\";\n        element.style.flex = \"0 0 auto\";\n        element.style.alignSelf = \"flex-start\";\n        // element.style.maxWidth = \"\";\n        // element.style.whiteSpace = \"nowrap\";\n\n    });\n}\n\n// ---------\n\nfunction fitTextToMaxRows(element, maxRowCount, {\n    minFontSize = 6,         // px\n    step = 0.05,              // mennyivel csökkentsen egy lépésben\n    maxIter = 500,            // végtelen ciklus elkerülésére\n} = {}) {\n\n    let style = window.getComputedStyle(element);\n    let currentFontSizePt = convertToPt(`${parseFloat(style.fontSize)}px`); // px-ben\n    let iter = 0;\n\n    while (iter < maxIter) {\n        const rowCount = getRenderedLineCountForNode(element);\n        if (rowCount <= maxRowCount) break;\n\n        currentFontSizePt = Math.max(currentFontSizePt - step, minFontSize);\n        element.style.fontSize = `${currentFontSizePt}pt`;\n\n        iter++;\n    }\n\n    console.log(iter);\n\n}\n\n// function fitTextToMaxRows(textNode, maxRowCount, {\n//     minFontSize = 6,         // px\n//     step = 0.5,              // mennyivel csökkentsen egy lépésben\n//     maxIter = 50,            // végtelen ciklus elkerülésére\n// } = {}) {\n//     if (!textNode || textNode.nodeType !== Node.TEXT_NODE) return;\n//\n//     const parent = textNode.parentElement;\n//     if (!parent) return;\n//\n//     let style = window.getComputedStyle(parent);\n//     let currentFontSizePt = convertToPt(`${parseFloat(style.fontSize)}px`); // px-ben\n//     let iter = 0;\n//\n//     while (iter < maxIter) {\n//         const rowCount = getTextNodeLineCount(textNode);\n//         if (rowCount <= maxRowCount) break;\n//\n//         currentFontSizePt = Math.max(currentFontSizePt - step, minFontSize);\n//         parent.style.fontSize = `${currentFontSizePt}pt`;\n//\n//         iter++;\n//     }\n//\n//     console.log(iter);\n//\n// }\n//\nexport { prepareElements, squeezeAll };","import {getElementBoxWidth, getRenderedLineCountForNode, getTextNodeLineCount} from \"../measurement\";\nimport convertToPt from \"../conversion\";\n\nconst elementsToSqueezeSpacing = [];\n\nfunction calculateSqueezedLetterSpacing(element, maxWidthPt, {\n    pxToPt = 0.74999943307122,          // 1px = 0.75pt (96dpi-n)\n    epsilonPt = 0.05,       // pontosság (pt)\n    maxIter = 20,           // bináris keresés lépések\n    minLSpt = -5,           // korlátok pt-ben\n    maxLSpt = 20\n} = {}) {\n\n    const toPt = (px) => px * pxToPt;\n    const toPx = (pt) => pt / pxToPt;\n\n    // 1) Cél szélesség pt-ben\n    const targetPt = maxWidthPt * 1; // már pt-ben érkezik\n    const text = element.textContent || \"\";\n    const gaps = Math.max(0, text.length - 1);\n    if (gaps === 0) {\n        return parseFloat(getComputedStyle(element).letterSpacing) * pxToPt || 0;\n    }\n\n    // 2) Jelenlegi állapot (px-ben mérünk → pt-re váltunk)\n    let currentLSpx = parseFloat(getComputedStyle(element).letterSpacing);\n    if (Number.isNaN(currentLSpx)) currentLSpx = 0;\n    let currentLSPt = toPt(currentLSpx);\n\n    let currentWidthPt = getElementBoxWidth(element);\n\n    // 3) Első becslés (lineáris modell)\n    let guessPt = currentLSPt;\n    if (gaps > 0) {\n        const extraPerGapPt = (targetPt - currentWidthPt) / gaps;\n        guessPt = currentLSPt + extraPerGapPt;\n    }\n    guessPt = Math.max(minLSpt, Math.min(maxLSpt, guessPt));\n\n    // alkalmazzuk ideiglenesen (px-ben kell beírni a style-ba!)\n    element.style.letterSpacing = toPx(guessPt) + \"px\";\n\n    // mérés\n    let wPt = getElementBoxWidth(element);\n    if (Math.abs(wPt - targetPt) <= epsilonPt) {\n        return guessPt;\n    }\n\n    // 4) Bináris keresés a pontos illesztéshez\n    let loPt, hiPt;\n    if (wPt < targetPt) { loPt = guessPt; hiPt = maxLSpt; }\n    else { loPt = minLSpt; hiPt = guessPt; }\n\n    for (let i = 0; i < maxIter; i++) {\n        const midPt = (loPt + hiPt) / 2;\n        element.style.letterSpacing = toPx(midPt) + \"px\";\n\n        wPt = getElementBoxWidth(element);\n        const diff = wPt - targetPt;\n        if (Math.abs(diff) <= epsilonPt) {\n            guessPt = midPt;\n            break;\n        }\n        if (diff < 0) loPt = midPt; else hiPt = midPt;\n        guessPt = midPt;\n    }\n\n    return guessPt; // PT-ben ad vissza, a te konvencióddal egyezően\n}\n\n\nfunction squeezeLetterSpacing(s) {\n\n    let rowCount = getRenderedLineCountForNode(s.element);\n    if (rowCount <= s.maxRows) {\n        return;\n    }\n\n    const epsilon = 0.005;\n    let scale = s.minLetterSpacingPt;\n\n    do  {\n        scale += epsilon;\n        s.element.style.letterSpacing = scale.toString() + \"pt\";\n        rowCount = getRenderedLineCountForNode(s.element);\n    } while (rowCount <= s.maxRows);\n\n    scale -= epsilon;\n    s.element.style.letterSpacing = scale.toString() + \"pt\";\n\n    // --------------\n\n}\n\n\n// function squeezeLetterSpacing(s) {\n//\n//     const rowCount = getTextNodeLineCount(s.element.childNodes[0]);\n//     if (rowCount <= s.maxRows && s.maxRows > 1) {\n//         return;\n//     }\n//\n//     if (s.maxRows > 1) {\n//         fitLetterSpacingToMaxRows(s.element.childNodes[0], s.maxRows, {\n//             minSpacing: s.minLetterSpacingPt\n//         });\n//         return;\n//     }\n//\n//\n//     const newLetterSpacingPt = calculateSqueezedLetterSpacing(\n//         s.element,\n//         s.maxWidthPt,\n//         // getElementBoxWidth(s.element),\n//         // originalLetterSpacing\n//     );\n//\n//     const finalLetterSpacingPt = Math.max(Math.min(newLetterSpacingPt, s.maxLetterSpacingPt), s.minLetterSpacingPt);\n//\n//     s.element.style.letterSpacing = finalLetterSpacingPt.toString() + \"pt\";\n//     s.element.style.maxWidth = s.maxWidth + \"pt\";\n// }\n//\n// Adjust letter-spacing for all elements\nfunction squeezeAllLetterSpacing() {\n    for (var i in elementsToSqueezeSpacing) {\n        squeezeLetterSpacing(elementsToSqueezeSpacing[i]);\n    }\n}\n\nfunction getElementsToSqueezeLetterSpacing () {\n    const squeezeElements = document.querySelectorAll('.squeeze-spacing');\n    const squeezeElementsWithParams = [];\n\n    // convert nodeList to array\n    for (var i=0; i<squeezeElements.length; i++) {\n        squeezeElementsWithParams.push(squeezeElements[i]);\n    }\n\n    return squeezeElementsWithParams;\n}\n\n// Preparation logic remains mostly the same\nfunction prepareElementsForLetterSpacing() {\n    const elements = getElementsToSqueezeLetterSpacing();\n    elements.map(function (element, index) {\n\n        let maxWidth = window.getComputedStyle(element).maxWidth;\n        if (!maxWidth || maxWidth === \"none\") {\n            element.style.maxWidth = \"inherit\";\n            maxWidth = window.getComputedStyle(element).maxWidth;\n        }\n\n        if (!maxWidth || maxWidth === \"none\") {\n            return;\n        }\n\n        const maxWidthPt = convertToPt(maxWidth);\n\n        const classArray = Array.from(element.classList);\n        const maxMatch = classArray.find(c => c.startsWith('max-letter-spacing-'))?.match(/^max-letter-spacing-\\[([^\\]]+)\\]$/);\n        const maxLetterSpacingPt = maxMatch ? convertToPt(maxMatch[1]) : 0;\n        const minMatch = classArray.find(c => c.startsWith('min-letter-spacing-'))?.match(/^min-letter-spacing-\\[([^\\]]+)\\]$/);\n        const minLetterSpacingPt = minMatch ? convertToPt(minMatch[1]) : -1;\n\n        const maxRowsMatch = classArray.find(c => c.startsWith('max-rows-'))?.match(/^max-rows-\\[([^\\]]+)\\]$/);\n        const maxRows = maxRowsMatch ? maxRowsMatch[1] : 1;\n\n        elementsToSqueezeSpacing[index] = {\n            element: elements[index],\n            maxWidthPt: maxWidthPt,\n            maxLetterSpacingPt: maxLetterSpacingPt,\n            minLetterSpacingPt: minLetterSpacingPt,\n            maxRows: maxRows,\n        };\n\n        // element.style.letterSpacing = \"0.1px\";\n        // element.style.maxWidth = \"\";\n        // element.style.width = \"fit-content\";\n        element.style.display = \"inline-block\";\n        element.style.flex = \"0 0 auto\";\n        element.style.alignSelf = \"flex-start\";\n        // element.style.whiteSpace = \"nowrap\"; // Prevent wrapping\n    });\n}\n\nfunction fitLetterSpacingToMaxRows(textNode, maxRows, {\n    minSpacing = -5,   // px – alsó korlát\n    step = 0.2,        // px – ennyivel csökkentünk iterációnként\n    maxIter = 0,      // véd a végtelen ciklus ellen\n} = {}) {\n    if (!textNode || textNode.nodeType !== Node.TEXT_NODE) return;\n\n    const parent = textNode.parentElement;\n    if (!parent) return;\n\n    const style = window.getComputedStyle(parent);\n    let currentSpacingPt = convertToPt(`${parseFloat(style.letterSpacing) || 0}px`);\n    let iter = 0;\n\n    while (iter < maxIter) {\n        const rowCount = getTextNodeLineCount(textNode);\n        if (rowCount <= maxRows) break; // elértük vagy alatta vagyunk → kész\n\n        currentSpacingPt = Math.max(currentSpacingPt - step, minSpacing);\n        parent.style.letterSpacing = `${currentSpacingPt}pt`;\n\n        iter++;\n    }\n\n    return currentSpacingPt; // visszaadja a végső értéket\n}\n\nexport { prepareElementsForLetterSpacing, squeezeAllLetterSpacing };\n\n\n","import convertToPt from \"../conversion\";\nimport {getElementBoxWidth, getRenderedLineCountForNode, getScaleX} from \"../measurement\";\n\nconst elementsToSqueezeScaling = [];\n\nfunction getElementsToScaling () {\n    const squeezeElements = document.querySelectorAll('.squeeze-scaling');\n    const squeezeElementsWithParams = [];\n\n    // convert nodeList to array\n    for (var i=0; i<squeezeElements.length; i++) {\n        squeezeElementsWithParams.push(squeezeElements[i]);\n    }\n\n    return squeezeElementsWithParams;\n}\n\nfunction prepareElementsForScaling() {\n    const elements = getElementsToScaling();\n    elements.map(function (element, index) {\n\n        let maxWidth = window.getComputedStyle(element).maxWidth;\n        if (!maxWidth || maxWidth === \"none\") {\n            element.style.maxWidth = \"inherit\";\n            maxWidth = window.getComputedStyle(element).maxWidth;\n        }\n        const maxFontSize = window.getComputedStyle(element).fontSize;\n        const currentWidth = window.getComputedStyle(element).width;\n\n        if (!maxWidth || !maxFontSize || maxWidth === \"none\" || maxFontSize === \"none\") {\n            return;\n        }\n\n        // element.innerHTML = \"\";\n        element.style.width = maxWidth;\n        const maxWidthPt = getElementBoxWidth(element, false);\n        element.style.width = 'fit-content';\n\n        const maxFontSizePt = convertToPt(maxFontSize);\n\n        const classArray = Array.from(element.classList);\n        const maxMatch = classArray.find(c => c.startsWith('max-scale-'))?.match(/^max-scale-\\[([^\\]]+)\\]$/);\n        const maxScale = maxMatch ? parseFloat(maxMatch[1]) : 1;\n        const minMatch = classArray.find(c => c.startsWith('min-scale-'))?.match(/^min-scale-\\[([^\\]]+)\\]$/);\n        const minScale = minMatch ? parseFloat(minMatch[1]) : 1;\n\n        const maxRowsMatch = classArray.find(c => c.startsWith('max-rows-'))?.match(/^max-rows-\\[([^\\]]+)\\]$/);\n        const maxRows = maxRowsMatch ? maxRowsMatch[1] : 1;\n\n\n        elementsToSqueezeScaling[index] = {\n            element: elements[index],\n            maxWidthPt: maxWidthPt,\n            maxFontSizePt: maxFontSizePt,\n            maxScale: maxScale,\n            minScale: minScale,\n            maxRows: maxRows\n        };\n\n        element.style.transform = \"scale(1, 1)\";\n        element.style.transformOrigin = \"left center\";\n        element.style.display = \"inline-block\";\n        element.style.flex = \"0 0 auto\";\n        element.style.alignSelf = \"flex-start\";\n        element.style.maxWidth = \"\";\n        // element.style.whiteSpace = \"nowrap\";\n\n    });\n}\n\n// /**\n//  * A szöveg szélességét scale-lel illeszti a kívánt maxWidthPt-re.\n//  * - csak X irányban skáláz (alapértelmezés), Y-t 1-en hagyja\n//  * - pt-ben (printer world) számol, a style-ba px alapú scale kerül\n//  * - megtartja az eredeti transformot (előre teszi a scale-t)\n//  *\n//  * @param {HTMLElement} element   - a skálázandó elem\n//  * @param {number}      maxWidthPt- cél szélesség pt-ben\n//  * @param {object}      opts\n//  *    pxToPt=0.75       - 1px = 0.75pt (96 dpi)\n//  *    axis='x'          - 'x' | 'uniform'  ('uniform' esetén X=Y skála)\n//  *    minScale=0.2      - skála alsó korlát\n//  *    maxScale=5        - skála felső korlát\n//  *    epsilon=0.05      - engedett hiba (pt)\n//  *    maxIter=5         - legfeljebb ennyiszer finomít\n//  *    setOrigin=true    - bal szélre állítja a transform-origin-t\n//  *\n//  * @returns {number}    - a végső X scale érték\n//  */\n// function calculateSqueezedScale(\n//     element,\n//     maxWidthPt,\n//     {\n//         pxToPt = 0.74999943307122,\n//         axis = 'x',         // 'x' vagy 'uniform'\n//         minScale = 0.8,\n//         maxScale = 1,\n//         epsilon = 0.05,\n//         maxIter = 0,\n//         setOrigin = true,\n//     } = {}\n// ) {\n//     const toPt = (px) => px * pxToPt;\n//     const toPx = (pt) => pt / pxToPt;\n//\n//     // 1) Cél szélesség px-ben\n//     const targetPt = maxWidthPt;\n//     // const targetPx = toPx(maxWidthPt);\n//\n//     // 2) Eredeti transform elmentése, méréshez ideiglenesen kikapcsoljuk a skálát\n//     const prevTransform = element.style.transform || '';\n//     const prevOrigin = element.style.transformOrigin || '';\n//\n//     // a legegyszerűbb és legstabilabb: ideiglenesen 'none', hogy a nyers szélességet mérjük\n//     element.style.transform = 'none';\n//     if (setOrigin) element.style.transformOrigin = 'left center';\n//\n//     // 3) Nyers (skála nélküli) szélesség\n//     const baseWidthPt = getElementBoxWidth(element) || 0;\n//     // const baseWidthPx = element.getBoundingClientRect().width || 0;\n//     if (baseWidthPt <= 0) {\n//         // nincs értelmezhető szélesség – ne robbanjon\n//         element.style.transform = prevTransform;\n//         element.style.transformOrigin = prevOrigin;\n//         return 1;\n//     }\n//\n//     // 4) Első becslés: arányos skála\n//     let sx = clamp(targetPt / baseWidthPt, minScale, maxScale);\n//     console.log(`sx1: ${sx}`);\n//     let sy = (axis === 'uniform') ? sx : 1;\n//\n//     // alkalmazzuk: a scale-t előre tesszük, a meglévő transform megmarad\n//     element.style.transform = `scale(${sx}, ${sy})`.trim();\n//     // element.style.transform = `scale(${sx}, ${sy}) ${prevTransform}`.trim();\n//\n//     // 5) Finomhangolás (iteratív, gyors konvergencia)\n//     for (let i = 0; i < maxIter; i++) {\n//         const w = getElementBoxWidth(element);\n//         // const w = element.getBoundingClientRect().width;\n//         const diffPt = targetPt - w;\n//         if (Math.abs(diffPt) <= epsilon) break;\n//\n//         // multiplikatív korrekció: új sx = régi sx * (cél / mért)\n//         const factor = targetPt / (w || 1);\n//         sx = clamp(sx * factor, minScale, maxScale);\n//         console.log(`w: ${w} - sx2: ${sx}`);\n//         sy = (axis === 'uniform') ? sx : 1;\n//         element.style.transform = `scale(${sx}, ${sy})`.trim();\n//         // element.style.transform = `scale(${sx}, ${sy}) ${prevTransform}`.trim();\n//     }\n//\n//     // (opcionális) ha nem akarsz origin-t hagyni:\n//     if (!setOrigin) element.style.transformOrigin = prevOrigin;\n//\n//     console.log(`sx3: ${sx}`);\n//     return sx;\n//\n//     function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }\n// }\n\n\n\nfunction squeezeScale(s) {\n\n    // ha s.maxRows == 1, sima squeeze\n    // ha max squeeze és no squeeze esetén a row count különbözik, akkor\n    // keresd meg, azt a squeeze legkisebb mértéket, ami még ugyanannyi rows-t eredményez mint a max squeeze\n\n    // applyTransformX(s.element, `scale(${s.minScale}, 1)`);\n    // const minRowCount = getRenderedLineCountForNode(s.element);\n    // applyTransformX(s.element, `scale(1, 1)`);\n    // const maxRowCount = getRenderedLineCountForNode(s.element);\n    //\n    // if (maxRowCount > minRowCount) {\n    //     // keresd azt a squeeze legkisebb mértéket ami minRowCount-ot eredményez\n    //     let scale = s.minScale;\n    //     let rowCount = minRowCount;\n    //     const epsilon = 0.005;\n    //\n    //     while (rowCount === minRowCount) {\n    //         scale += epsilon;\n    //         applyTransformX(s.element, `scale(${scale}, 1)`);\n    //         rowCount = getRenderedLineCountForNode(s.element);\n    //     }\n    //\n    //     scale -= epsilon;\n    //     applyTransformX(s.element, `scale(${scale}, 1)`);\n    //\n    // }\n    //\n    // return;\n\n    // console.log(minRowCount, maxRowCount);\n\n    let rowCount = getRenderedLineCountForNode(s.element);\n    if (rowCount <= s.maxRows) {\n        return;\n    }\n\n    let scale = s.maxScale;\n    const epsilon = 0.005;\n    while (rowCount > s.maxRows && scale >= s.minScale) {\n        scale -= epsilon;\n        applyTransformX(s.element, `scale(${scale}, 1)`);\n        rowCount = getRenderedLineCountForNode(s.element);\n    }\n\n\n\n    // const newScale = calculateSqueezedScale(\n    //     s.element,\n    //     s.maxWidthPt,\n    //     {\n    //         minScale: s.minScale,\n    //     }\n    //     // getElementBoxWidth(s.element),\n    // );\n    //\n    // const maxScale = s.maxScale ?? newScale;\n    // const minScale = s.minScale ?? newScale;\n    // const finalScale = Math.max(Math.min(newScale, Number(maxScale)), Number(minScale));\n    // const finalScaleString = `scale(${finalScale}, 1)`;\n    //\n    // applyTransformX(s.element, finalScaleString);\n\n    // s.element.style.transform = finalScaleString;\n    // const scaleX = getScaleX(s.element);\n    // s.element.style.maxWidth = `${Math.ceil(100*100 / (scaleX))/100}%`;\n    // s.element.style.width = `${Math.ceil(100*100 / (scaleX))/100}%`;\n    // // s.element.style.maxWidth = `${s.maxWidthPt / finalScale}pt`;\n    // // s.element.style.width = `${s.maxWidthPt / finalScale}pt`;\n\n\n}\n\nfunction applyTransformX(el, scaleString) {\n    el.style.transform = scaleString;\n    const scaleX = getScaleX(el);\n    el.style.maxWidth = `${Math.ceil(10*100 / (scaleX))/10}%`;\n    // el.style.width = `fit-content`;\n    el.style.width = `${Math.ceil(10*100 / (scaleX))/10}%`;\n\n    // el.style.maxWidth = `${Math.ceil(100*100 / (scaleX))/100}%`;\n    // // el.style.width = `fit-content`;\n    // el.style.width = `${Math.ceil(100*100 / (scaleX))/100}%`;\n}\n\n\nfunction squeezeAllScaling() {\n    for (var i in elementsToSqueezeScaling) {\n        squeezeScale(elementsToSqueezeScaling[i]);\n    }\n}\n\nexport { prepareElementsForScaling, squeezeAllScaling };\n","import handleSeparators from \"./separator\";\nimport { prepareElements, squeezeAll } from \"./squeeze/squeeze-font-size\";\nimport { prepareElementsForLetterSpacing, squeezeAllLetterSpacing } from \"./squeeze/squeeze-letter-spacing\";\nimport { prepareElementsForScaling, squeezeAllScaling } from \"./squeeze/squeeze-scaling\";\n\nfunction runSqueeze() {\n    console.log(\"SQUEEZING\");\n\n    prepareElements();\n    prepareElementsForLetterSpacing();\n    prepareElementsForScaling();\n\n    squeezeAll();\n    squeezeAllLetterSpacing();\n    squeezeAllScaling();\n\n    // handleSeparators();\n}\n\nexport default runSqueeze;","import {renderTemplate, zoom} from \"./render-template\";\nfunction addPostMessageHandler() {\n    window.addEventListener('message', (event) => {\n        // console.log('Message received from parent:', event.data);\n\n        const sourceNode = document.getElementById('entry-template');\n\n        if (!event.data.data || !sourceNode) {\n            return;\n        }\n\n        const data = {};\n        Object.keys(event.data.data).map((key) => {\n            if (Array.isArray(event.data.data[key]) && (event.data.data[key].length > 0)) {\n                if (event.data.data[key][0]?.uuid) {\n                    data[key] = `https://bar-dev.wheel.digital/client-api/file-manager/${event.data.data[key][0].uuid}`;\n                } else {\n                    data[key] = event.data.data[key][0].label;\n                }\n            } else {\n                data[key] = event.data.data[key];\n            }\n        });\n\n        if (event.data.msgId === \"dataChanged\") {\n            renderTemplate(data, event.data.templateId, event.data.orderLineUuid, event.data.options, false);\n            zoom(event.data.zoom / 100);\n        }\n\n        if (event.data.msgId === \"getRenderedMarkup\") {\n            renderTemplate(data, event.data.templateId, event.data.orderLineUuid, event.data.options, true);\n            zoom(event.data.zoom / 100);\n        }\n\n        if (event.data.msgId === \"zoom\") {\n            zoom(event.data.data / 100);\n        }\n\n    });\n}\n\nexport {addPostMessageHandler};","import handleSeparators from \"./separator.js\";\nimport {renderTemplate, setTemplateScripts} from \"./render-template\";\nimport smartCaps from \"./smart-caps\";\nimport runSqueeze from \"./squeeze\";\nimport {addPostMessageHandler} from \"./post-msg-handler\";\n\nconst templateScripts = () => {\n    smartCaps();\n    runSqueeze();\n    handleSeparators();\n}\n\nfunction addPodScripts(data) {\n\n    async function init(data) {\n\n        setTemplateScripts(templateScripts);\n\n        addPostMessageHandler();\n\n        if (document.fonts?.ready) {\n            try { await document.fonts.ready; } catch {}\n        }\n\n        // const rendered = false;\n        let rendered = false;\n        if (document.getElementById(\"initial-render-script\")) {\n            rendered = renderTemplate(data);\n        }\n        // const rendered = renderTemplate({});\n\n        if (!rendered) {\n            templateScripts();\n        }\n    }\n\n    document.addEventListener(\"DOMContentLoaded\", async (event) => {\n        await init(data);\n    });\n\n    window.__PROCESSING_DONE__ = true;\n}\n\nexport default addPodScripts;"],"names":["handleSeparators","results","Array","from","document","querySelectorAll","map","el","m","className","match","element","value","filter","Boolean","forEach","_ref","textNodes","getAllTextNodes","node","wrapMatchesWithSeparatorAndSegments","separatorNodeList","separators","separator","next","nextElementSibling","prev","previousElementSibling","nextInNewLine","prevInNewLine","getYCoordinate","style","visibility","display","root","walker","createTreeWalker","NodeFilter","SHOW_TEXT","nodes","n","nextNode","parentNode","tagName","classList","item","push","textNode","_textNode$parentNode","text","nodeValue","valLen","length","idx","indexOf","frag","createDocumentFragment","start","before","slice","beforeTrim","trim","spanBefore","createElement","textContent","appendChild","createTextNode","sep","after","afterTrim","_after$match$","_after$match","_after$match$2","_after$match2","leadingWs","trailingWs","spanAfter","replaceChild","getBoundingClientRect","top","templateScripts","setTemplateScripts","scripts","renderTemplate","data","templateId","orderLineUuid","options","sendData","sourceNode","getElementById","Object","keys","source","innerHTML","safeData","JSON","parse","stringify","key","replace","renderer","Twig","twig","html","render","getElementsByTagName","outerHTML","window","parent","postMessage","zoom","ratio","scale","smartCaps","ignore","getTextNodesInSmartCap","arguments","undefined","result","elements","word","lower","toLowerCase","includes","startsWith","prefix","rest","charAt","toUpperCase","smartCapsNodeList","smartCap","convertToPt","size","dpi","pointsPerInch","conversionFactors","pt","px","mm","cm","in","pc","em","rem","Error","parseFloat","unit","getElementBoxWidth","overflown","Element","maxWidth","whiteSpace","transform","offsetWidth","wPx","width","wPx2","concat","Math","max","out","getRenderedLineCountForNode","_ref$epsilon","epsilon","rects","_iterator","_createForOfIteratorHelper","_step","s","done","tn","range","createRange","selectNodeContents","rlist","getClientRects","i","r","height","bottom","left","right","err","e","f","sort","a","b","lines","currentTop","_i","_rects","abs","getScaleX","getComputedStyle","values","split","elementsToSqueeze","calculateSqueezedFontSize","maxFontSizePt","maxWidthPt","actualWidthPt","actualFontSizePt","newFontSizePt","min","squeeze","rowCount","maxRows","fitTextToMaxRows","minFontSize","minFontSizePt","actualFontSize","fontSize","console","log","id","toString","getElementsToSqueeze","squeezeElements","squeezeElementsWithParams","squeezeAll","prepareElements","index","_classArray$find","_classArray$find2","_classArray$find3","maxFontSize","currentWidth","classArray","maxMatch","find","c","minMatch","maxRowsMatch","flex","alignSelf","maxRowCount","_ref$minFontSize","_ref$step","step","_ref$maxIter","maxIter","currentFontSizePt","iter","elementsToSqueezeSpacing","squeezeLetterSpacing","minLetterSpacingPt","letterSpacing","squeezeAllLetterSpacing","getElementsToSqueezeLetterSpacing","prepareElementsForLetterSpacing","maxLetterSpacingPt","elementsToSqueezeScaling","getElementsToScaling","prepareElementsForScaling","maxScale","minScale","transformOrigin","squeezeScale","applyTransformX","scaleString","scaleX","ceil","squeezeAllScaling","runSqueeze","addPostMessageHandler","addEventListener","event","isArray","_event$data$data$key$","uuid","label","msgId","addPodScripts","init","_x","_init","apply","_asyncToGenerator","_regenerator","_callee2","_document$fonts","rendered","w","_context2","p","fonts","ready","v","_callee","_context","_x2","__PROCESSING_DONE__"],"mappings":"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"}